---
title: Server
description: Set up Better Auth with Convex database adapter.
links:
  doc: https://www.better-auth.com/docs/installation
---

import { InfoIcon } from "lucide-react"

In this guide, we'll set up Better Auth with Convex as the database adapter. You'll configure the auth client, define the schema, register HTTP routes, and sync environment variables.

## Overview

The server setup involves these components:

| Component | Description |
|-----------|-------------|
| Auth config | JWT provider configuration |
| Auth client | Convex adapter with triggers |
| Schema | Auth tables in your app schema |
| HTTP routes | Better Auth endpoints |
| Environment | Secrets and provider credentials |

Let's set it up step by step.

## Authentication Flow

Before diving into setup, let's understand how authentication flows through your app. This will help you understand why we configure things the way we do.

### SSR Flow (HTTP Prefetching)

When you call `caller.posts.list()` on the server, here's what happens:

```
┌─────────────────────────────────────────────────────────────────────────┐
│  SSR REQUEST (server-side data fetching)                                 │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  1. Get JWT Token                                                        │
│     ┌─────────────────────────────────────────────────────────────────┐ │
│     │ JWT Caching ENABLED (default)                                   │ │
│     │   ├─ Check cookie for cached JWT                                │ │
│     │   ├─ If valid & not expired → use cached token (0ms)            │ │
│     │   └─ If missing/expired → fetch fresh token from auth endpoint  │ │
│     └─────────────────────────────────────────────────────────────────┘ │
│     ┌─────────────────────────────────────────────────────────────────┐ │
│     │ JWT Caching DISABLED                                            │ │
│     │   └─ Always fetch fresh token from auth endpoint                │ │
│     └─────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  2. HTTP Request to Convex (fetchQuery)                                  │
│     Server → Convex backend with JWT in Authorization header             │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  3. Token Validation (every HTTP request)                                │
│     ┌─────────────────────────────────────────────────────────────────┐ │
│     │ Dynamic JWKS                                                    │ │
│     │   ├─ Parse JWT claims (issuer, audience)                        │ │
│     │   ├─ Fetch OIDC discovery ← +50-200ms network call              │ │
│     │   ├─ Fetch JWKS keys     ← +50-200ms network call               │ │
│     │   └─ Verify signature                                           │ │
│     │   ADDED LATENCY: +100-400ms per request                         │ │
│     └─────────────────────────────────────────────────────────────────┘ │
│     ┌─────────────────────────────────────────────────────────────────┐ │
│     │ Static JWKS (recommended)                                       │ │
│     │   ├─ Parse JWT claims                                           │ │
│     │   └─ Verify signature using embedded keys                       │ │
│     │   ADDED LATENCY: negligible per request                         │ │
│     └─────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  4. Query Executes & Response                                            │
│     Data cached in TanStack Query, rendered to HTML                      │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  5. Hydration (fire-and-forget preloading)                               │
│     ├─ HTML sent to browser with dehydrated query cache                 │
│     ├─ Client hydrates with prefetched data (instant render)            │
│     └─ WebSocket subscribes for real-time updates                       │
└─────────────────────────────────────────────────────────────────────────┘
```

JWT caching is **enabled by default** in `convexBetterAuth`, so you don't need to configure anything. If you need to disable it for debugging:

```ts title="src/lib/convex/server.ts" showLineNumbers {5}
export const { createContext, createCaller, handler } = convexBetterAuth({
  api,
  convexSiteUrl: process.env.NEXT_PUBLIC_CONVEX_SITE_URL!,
  meta,
  auth: { jwtCache: false },
});
```

### Client Flow (WebSocket)

Now let's look at what happens when you use `useCRPC().posts.list.useQuery()` in client components. This is where Convex differs from traditional REST APIs:

```
┌─────────────────────────────────────────────────────────────────────────┐
│  PAGE LOAD / NAVIGATION                                                  │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  1. WebSocket Connection                                                 │
│     Browser → Convex backend (establishes persistent connection)         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  2. Auth Handshake (⚠️ BLOCKING - queries wait here)                     │
│     ┌─────────────────────────────────────────────────────────────────┐ │
│     │ Unlike REST APIs where queries start immediately, Convex        │ │
│     │ WebSocket requires auth validation BEFORE any query can run.    │ │
│     └─────────────────────────────────────────────────────────────────┘ │
│     Client sends session token → Convex validates JWT                   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  3. Token Validation                                                     │
│     ┌─────────────────────────────────────────────────────────────────┐ │
│     │ Static JWKS (recommended)                                       │ │
│     │   ├─ Parse JWT claims                                           │ │
│     │   └─ Verify signature using embedded keys                       │ │
│     │   → Instant validation, no network calls                        │ │
│     └─────────────────────────────────────────────────────────────────┘ │
│     ┌─────────────────────────────────────────────────────────────────┐ │
│     │ Dynamic JWKS (not recommended)                                  │ │
│     │   ├─ Fetch OIDC discovery ← +50-200ms network call              │ │
│     │   ├─ Fetch JWKS keys     ← +50-200ms network call               │ │
│     │   └─ Verify signature                                           │ │
│     │   → +100-400ms delay before ANY query can run                   │ │
│     └─────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  4. Identity Cached → Queries Unblocked                                  │
│     All pending queries now execute instantly                            │
│     useQuery(crpc.posts.list.queryOptions()) → runs                      │
│     useQuery(crpc.user.me.queryOptions())    → runs                      │
│     ... navigate to other pages → all queries instant                    │
└─────────────────────────────────────────────────────────────────────────┘
```

<Callout icon={<InfoIcon />}>
**Key difference from REST APIs:** REST queries fire immediately and validate auth inline on the server. Convex WebSocket queries are **blocked until the auth handshake completes**. This is why we use Static JWKS - it makes this handshake instant.
</Callout>

That's the full picture. Now let's set it up.

## Prerequisites

We'll start by installing the required packages:

```bash
bun add better-auth@1.4.9 @convex-dev/better-auth better-convex hono
```

<Callout icon={<InfoIcon />}>
Pin `better-auth` to avoid breaking changes. Check [Better Auth releases](https://github.com/better-auth/better-auth/releases) for updates.
</Callout>

## 1. Auth Config

Next, we'll create the auth configuration file. This tells Convex how to validate JWTs using Static JWKS:

```ts title="convex/functions/auth.config.ts" showLineNumbers {4-6}
import { getAuthConfigProvider } from '@convex-dev/better-auth/auth-config';
import type { AuthConfig } from 'convex/server';

export default {
  providers: [getAuthConfigProvider({ jwks: process.env.JWKS })],
} satisfies AuthConfig;
```

## 2. Create Auth Client

Now we'll create the auth client. This connects Better Auth to your Convex database and lets you add triggers for user lifecycle events:

```ts title="convex/functions/auth.ts" showLineNumbers {8,11,14-15,23-27,43-47,52-55,60-67,70-82}
import { betterAuth, type BetterAuthOptions } from 'better-auth';
import { convex } from '@convex-dev/better-auth/plugins';
import { admin } from 'better-auth/plugins';
import { createClient, createApi, type AuthFunctions } from 'better-convex/auth';
import { internal } from './_generated/api';
import type { MutationCtx, QueryCtx } from './_generated/server';
import type { DataModel } from './_generated/dataModel';
import type { GenericCtx } from '../lib/crpc';
import schema from './schema';
import authConfig from './auth.config';

const authFunctions: AuthFunctions = internal.auth;

// Create client with Convex adapter and triggers
export const authClient = createClient<DataModel, typeof schema>({
  authFunctions,
  schema,
  internalMutation, // Optional: custom mutation wrapper (see below)
  triggers: {
    user: {
      beforeCreate: async (_ctx, data) => {
        // Ensure every user has a username
        const username =
          data.username?.trim() ||
          data.email?.split('@')[0] ||
          `user-${Date.now()}`;

        return { ...data, username };
      },
      // ctx.db version - for ctx.table, see Triggers documentation
      onCreate: async (ctx, user) => {
        // Create related records after signup
        await ctx.db.insert('profiles', {
          userId: user._id,
          bio: '',
        });
      },
    },
  },
});

// Auth options factory
export const createAuthOptions = (ctx: GenericCtx) =>
  ({
    baseURL: process.env.SITE_URL!,
    database: authClient.httpAdapter(ctx),
    plugins: [
      convex({
        authConfig,
        jwks: process.env.JWKS,
      }),
      admin(),
    ],
    session: {
      expiresIn: 60 * 60 * 24 * 30, // 30 days
      updateAge: 60 * 60 * 24 * 15, // 15 days
    },
    socialProviders: {
      google: {
        clientId: process.env.GOOGLE_CLIENT_ID!,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      },
    },
    // Fallback for CLI schema generation
    trustedOrigins: [process.env.SITE_URL ?? 'http://localhost:3000'],
  }) satisfies BetterAuthOptions;

// Create auth instance for HTTP routes
export const createAuth = (ctx: GenericCtx) => betterAuth(createAuthOptions(ctx));

// IMPORTANT: Use getAuth for queries/mutations (direct DB access)
export const getAuth = <Ctx extends QueryCtx | MutationCtx>(ctx: Ctx) => {
  return betterAuth({
    ...createAuthOptions(ctx),
    database: authClient.adapter(ctx, createAuthOptions),
  });
};

// Export trigger handlers for Convex
export const {
  beforeCreate,
  beforeDelete,
  beforeUpdate,
  onCreate,
  onDelete,
  onUpdate,
} = authClient.triggersApi();

// Export CRUD functions for Better Auth
export const {
  create,
  deleteMany,
  deleteOne,
  findMany,
  findOne,
  updateMany,
  updateOne,
  getLatestJwks,
  rotateKeys,
} = createApi(schema, createAuth, {
  internalMutation, // Optional: same wrapper as createClient
  skipValidation: true, // Smaller generated types
});

// Export auth instance for Better Auth CLI
// biome-ignore lint/suspicious/noExplicitAny: Required for CLI
export const auth = betterAuth(createAuthOptions({} as any));
```

<Callout icon={<InfoIcon />}>
Run `npx convex dev` first to generate `internal.auth` types.
</Callout>

## 3. Update Schema

Your database needs tables for users, sessions, accounts, and more. You have two options: generate them automatically or define them manually.

<Tabs groupId="schema" items={["CLI Generate", "Manual"]} persist>
  <Tab value="CLI Generate">
    The easiest approach is to let the Better Auth CLI generate the tables based on your plugins:

    ```bash
    npx @better-auth/cli generate -y --output convex/functions/authSchema.ts --config convex/functions/auth.ts
    ```

    Then import in your schema:

    ```ts title="convex/schema.ts" showLineNumbers {2,5}
    import { defineSchema } from 'convex/server';
    import { authSchema } from './authSchema';

    export default defineSchema({
      ...authSchema,
      // Your other tables
    });
    ```
  </Tab>
  <Tab value="Manual">
    If you prefer full control, define the auth tables directly in your schema:

    <Tabs groupId="db" items={["ctx.db", "ctx.table"]} persist>
      <Tab value="ctx.db">
        ```ts title="convex/schema.ts" showLineNumbers {6-20,22-33,35-47,49-55,57-61}
        import { defineSchema, defineTable } from 'convex/server';
        import { v } from 'convex/values';

        export default defineSchema({
          user: defineTable({
            name: v.string(),
            email: v.string(),
            emailVerified: v.boolean(),
            image: v.optional(v.string()),
            createdAt: v.number(),
            updatedAt: v.number(),
            // Admin plugin
            role: v.optional(v.string()),
            banned: v.optional(v.boolean()),
            banReason: v.optional(v.string()),
            banExpires: v.optional(v.number()),
          })
            .index('email', ['email']),

          session: defineTable({
            token: v.string(),
            expiresAt: v.number(),
            createdAt: v.number(),
            updatedAt: v.number(),
            ipAddress: v.optional(v.string()),
            userAgent: v.optional(v.string()),
            userId: v.string(),
            // Admin plugin
            impersonatedBy: v.optional(v.string()),
          })
            .index('token', ['token'])
            .index('userId', ['userId']),

          account: defineTable({
            accountId: v.string(),
            providerId: v.string(),
            userId: v.string(),
            accessToken: v.optional(v.string()),
            refreshToken: v.optional(v.string()),
            idToken: v.optional(v.string()),
            accessTokenExpiresAt: v.optional(v.number()),
            refreshTokenExpiresAt: v.optional(v.number()),
            scope: v.optional(v.string()),
            password: v.optional(v.string()),
            createdAt: v.number(),
            updatedAt: v.number(),
          })
            .index('accountId', ['accountId'])
            .index('userId', ['userId']),

          verification: defineTable({
            identifier: v.string(),
            value: v.string(),
            expiresAt: v.number(),
            createdAt: v.optional(v.number()),
            updatedAt: v.optional(v.number()),
          })
            .index('identifier', ['identifier']),

          jwks: defineTable({
            publicKey: v.string(),
            privateKey: v.string(),
            createdAt: v.number(),
          }),

          // Your other tables
        });
        ```
      </Tab>
      <Tab value="ctx.table">
        ```ts title="convex/schema.ts" showLineNumbers {5-18,20-28,30-42,44-50,52-56}
        import { v } from 'convex/values';
        import { defineEnt, defineEntSchema, getEntDefinitions } from 'convex-ents';

        const schema = defineEntSchema({
          user: defineEnt({
            name: v.string(),
            email: v.string(),
            emailVerified: v.boolean(),
            image: v.optional(v.string()),
            createdAt: v.number(),
            updatedAt: v.number(),
            // Admin plugin
            role: v.optional(v.string()),
            banned: v.optional(v.boolean()),
            banReason: v.optional(v.string()),
            banExpires: v.optional(v.number()),
          })
            .index('email', ['email'])
            .edges('sessions', { to: 'session', ref: 'userId' })
            .edges('accounts', { to: 'account', ref: 'userId' }),

          session: defineEnt({
            token: v.string(),
            expiresAt: v.number(),
            createdAt: v.number(),
            updatedAt: v.number(),
            ipAddress: v.optional(v.string()),
            userAgent: v.optional(v.string()),
            // Admin plugin
            impersonatedBy: v.optional(v.string()),
          })
            .index('token', ['token'])
            .edge('user', { to: 'user', field: 'userId' }),

          account: defineEnt({
            accountId: v.string(),
            providerId: v.string(),
            accessToken: v.optional(v.string()),
            refreshToken: v.optional(v.string()),
            idToken: v.optional(v.string()),
            accessTokenExpiresAt: v.optional(v.number()),
            refreshTokenExpiresAt: v.optional(v.number()),
            scope: v.optional(v.string()),
            password: v.optional(v.string()),
            createdAt: v.number(),
            updatedAt: v.number(),
          })
            .index('accountId', ['accountId'])
            .edge('user', { to: 'user', field: 'userId' }),

          verification: defineEnt({
            identifier: v.string(),
            value: v.string(),
            expiresAt: v.number(),
            createdAt: v.optional(v.number()),
            updatedAt: v.optional(v.number()),
          })
            .index('identifier', ['identifier']),

          jwks: defineEnt({
            publicKey: v.string(),
            privateKey: v.string(),
            createdAt: v.number(),
          }),

          // Your other tables
        });

        export default schema;
        export const entDefinitions = getEntDefinitions(schema);
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

Add custom indexes as needed:

```ts title="convex/schema.ts" showLineNumbers
// Override with custom indexes
user: authSchema.user.index('username', ['username']),
```

## 4. HTTP Routes

Now we'll expose Better Auth's endpoints via HTTP. We use Hono as the router:

```ts title="convex/functions/http.ts" showLineNumbers {1-5,9-18,21}
import '../lib/http-polyfills';
import { authMiddleware } from 'better-convex/auth';
import { createHttpRouter } from 'better-convex/server';
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { router } from '../lib/crpc';
import { createAuth } from './auth';

const app = new Hono();

// CORS for API routes
app.use(
  '/api/*',
  cors({
    origin: process.env.SITE_URL!,
    allowHeaders: ['Content-Type', 'Authorization', 'Better-Auth-Cookie'],
    exposeHeaders: ['Set-Better-Auth-Cookie'],
    credentials: true,
  })
);

// Better Auth middleware
app.use(authMiddleware(createAuth));

export const appRouter = router({
  // Add your routers here
});

export default createHttpRouter(app, appRouter);
```

See [HTTP Router](/docs/server/http) for route examples, webhooks, and streaming.

## 5. Sync Environment Variables

Finally, we need to set up environment variables. Create `convex/.env`:

```bash title="convex/.env" showLineNumbers
SITE_URL=http://localhost:3000
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
```

With Convex dev server running (`npx convex dev`), sync to Convex in another terminal:

```bash
npx better-convex env sync --auth
```

The `--auth` flag auto-generates `BETTER_AUTH_SECRET` and `JWKS` if they don't exist. See [CLI Reference](/docs/cli#env) for more options.

That's it for the basic setup! Your auth is now configured. To rotate keys later (this invalidates all tokens):

```bash
npx convex run auth:rotateKeys | npx convex env set JWKS
```

## Framework Integration

You've set up the Convex backend. Now let's connect your frontend:

<Cards>
  <Card title="React Setup" href="/docs/react/setup#with-auth" description="ConvexAuthProvider setup" />
  <Card title="Next.js Setup" href="/docs/nextjs/setup" description="Server-side rendering + RSC" />
</Cards>

## Key Concepts

Now that you have auth working, let's understand a few important concepts.

### Direct DB Access vs HTTP Adapter

The auth client provides two adapters depending on where you're calling from:

```ts showLineNumbers {2-4,8-10}
// ✅ In queries/mutations: Use getAuth (direct DB access)
export const someQuery = publicQuery
  .query(async ({ ctx }) => {
    const auth = getAuth(ctx);
    const session = await auth.api.getSession({ headers: await getHeaders(ctx) });
  });

// ✅ In HTTP routes/actions: Use createAuth (HTTP adapter)
export const someAction = publicAction
  .action(async ({ ctx }) => {
    const auth = createAuth(ctx);
    // Use for webhooks, external API calls
  });
```

**Why two adapters?**

| Adapter | Used by | Context | Performance |
|---------|---------|---------|-------------|
| `adapter` | `getAuth` | Queries/mutations | Direct DB access, no overhead |
| `httpAdapter` | `createAuth` | HTTP routes/actions | Uses `ctx.run*` internally |

<Callout icon={<InfoIcon />}>
**Performance:** The `httpAdapter` uses `ctx.runQuery`/`ctx.runMutation` internally, which adds **>50ms latency** per call (increasing with app size). Always use `getAuth` with direct DB access in queries and mutations.
</Callout>

### Custom Mutation Wrapper

Want to run custom logic when users are created or deleted? The `internalMutation` option lets you wrap auth mutations:

| Use Case | Description |
|----------|-------------|
| User aggregation | Maintain counts when users are created/deleted |
| Custom trigger systems | Projects using convex-helpers triggers |
| Middleware | Add logging, validation, or other cross-cutting concerns |

<Tabs groupId="db" items={["ctx.db", "ctx.table"]} persist>
  <Tab value="ctx.db">
    ```ts title="convex/lib/triggers.ts" showLineNumbers {6-17,19-22}
    import { Triggers } from 'convex-helpers/server/triggers';
    import { DataModel } from '../functions/_generated/dataModel';

    const triggers = new Triggers<DataModel>();

    // Maintain user count aggregate
    triggers.register('user', {
      async afterCreate(ctx, user) {
        const stats = await ctx.db.query('stats').first();
        if (stats) {
          await ctx.db.patch(stats._id, { totalUsers: stats.totalUsers + 1 });
        }
      },
      async afterDelete(ctx, user) {
        const stats = await ctx.db.query('stats').first();
        if (stats) {
          await ctx.db.patch(stats._id, { totalUsers: stats.totalUsers - 1 });
        }
      },
    });

    export const internalMutationWithTriggers = customMutation(
      internalMutation,
      customCtx(async (ctx) => ({ db: triggers.wrapDB(ctx).db }))
    );
    ```
  </Tab>
  <Tab value="ctx.table">
    ```ts title="convex/lib/triggers.ts" showLineNumbers {6-17,19-22}
    import { Triggers } from 'convex-helpers/server/triggers';
    import { DataModel } from '../functions/_generated/dataModel';

    const triggers = new Triggers<DataModel>();

    // Maintain user count aggregate
    triggers.register('user', {
      async afterCreate(ctx, user) {
        const stats = await ctx.table('stats').first();
        if (stats) {
          await stats.patch({ totalUsers: stats.totalUsers + 1 });
        }
      },
      async afterDelete(ctx, user) {
        const stats = await ctx.table('stats').first();
        if (stats) {
          await stats.patch({ totalUsers: stats.totalUsers - 1 });
        }
      },
    });

    export const internalMutationWithTriggers = customMutation(
      internalMutation,
      customCtx(async (ctx) => ({ db: triggers.wrapDB(ctx).db }))
    );
    ```
  </Tab>
</Tabs>

```ts title="convex/functions/auth.ts" showLineNumbers {1,4,8}
import { internalMutationWithTriggers } from './lib/triggers';

export const authClient = createClient({
  // ...
  internalMutation: internalMutationWithTriggers,
});

export const { ... } = createApi(schema, createAuth, {
  internalMutation: internalMutationWithTriggers,
});
```

Without `internalMutation`, auth operations use the default Convex `internalMutation` and won't trigger your custom logic.

## Environment Variables

Here's a quick reference for all the environment variables:

| Variable | Description |
|----------|-------------|
| `SITE_URL` | Your app URL (e.g., `http://localhost:3000`) |
| `JWKS` | Auto-generated by `env sync` |
| `BETTER_AUTH_SECRET` | Auto-generated by `env sync` |

Social providers (optional):

| Variable | Description |
|----------|-------------|
| `GOOGLE_CLIENT_ID` | Google OAuth client ID |
| `GOOGLE_CLIENT_SECRET` | Google OAuth client secret |

Run `npx better-convex env sync` to sync all variables to Convex.

## Production Deployment

Your first production deployment will fail authentication because JWKS isn't set yet. Don't worry - here's how to fix it:

**1. Deploy your app to production**

```bash
npx convex deploy --prod
```

Authentication will fail at this point - that's expected.

**2. Generate and set JWKS**

Run from your local machine with Convex CLI authenticated:

```bash
npx convex run auth:getLatestJwks --prod | npx convex env set JWKS --prod
```

This generates new signing keys (if none exist) and sets the JWKS environment variable.

**3. Verify authentication works**

Test a protected endpoint or sign in through your app. Authentication should now succeed.

<Callout icon={<InfoIcon />}>
**Troubleshooting:** If you see "Invalid token signature" errors after deployment, your JWKS may be outdated. Re-run the `getLatestJwks` command to sync.
</Callout>

## Key Rotation

Need to rotate signing keys? Maybe for security compliance or after a suspected compromise:

```bash
npx convex run auth:rotateKeys --prod | npx convex env set JWKS --prod
```

<Callout icon={<InfoIcon />}>
**Warning:** Key rotation invalidates all existing tokens. All users will be logged out and must re-authenticate. Plan rotations during low-traffic periods.
</Callout>

**Rotation checklist:**
- Schedule during low-traffic window
- Notify users about required re-login (optional)
- Run `rotateKeys` command
- Verify authentication works with new keys
- Monitor for authentication errors

## Helpers

These helpers extract user identity and session data from Convex context. You'll use them in your queries and mutations.

### getAuthUserIdentity

Returns the full user identity:

```ts showLineNumbers {1,3,5-8}
import { getAuthUserIdentity } from 'better-convex/auth';

const identity = await getAuthUserIdentity(ctx);

if (identity) {
  identity.userId;    // Id<'user'>
  identity.sessionId; // Id<'session'>
  identity.subject;   // string (user ID as string)
}
```

### getAuthUserId

If you just need the user ID:

<Tabs groupId="db" items={["ctx.db", "ctx.table"]} persist>
  <Tab value="ctx.db">
    ```ts showLineNumbers {1,3,5-7,10}
    import { getAuthUserId } from 'better-convex/auth';

    const userId = await getAuthUserId(ctx);

    if (!userId) {
      throw new CRPCError({ code: 'UNAUTHORIZED' });
    }

    // userId is Id<'user'>
    const user = await ctx.db.get(userId);
    ```
  </Tab>
  <Tab value="ctx.table">
    ```ts showLineNumbers {1,3,5-7,10}
    import { getAuthUserId } from 'better-convex/auth';

    const userId = await getAuthUserId(ctx);

    if (!userId) {
      throw new CRPCError({ code: 'UNAUTHORIZED' });
    }

    // userId is Id<'user'>
    const user = await ctx.table('user').get(userId);
    ```
  </Tab>
</Tabs>

### getSession

Returns the full session document:

```ts showLineNumbers {1,3,5-10}
import { getSession } from 'better-convex/auth';

const session = await getSession(ctx);

if (session) {
  session._id;                  // Id<'session'>
  session.userId;               // Id<'user'>
  session.activeOrganizationId; // Id<'organization'> | null
  session.expiresAt;            // number
}
```

### getHeaders

Need to call an external API with the current session? This builds the headers:

```ts showLineNumbers {1,3-4,7-9}
import { getHeaders } from 'better-convex/auth';

const headers = await getHeaders(ctx);
// Headers { authorization: 'Bearer ...', x-forwarded-for: '...' }

// Use with fetch
const response = await fetch('https://api.example.com', {
  headers,
});
```

## Next Steps

Done! You now have authentication set up. Here's where to go next:

<Cards>
  <Card title="Templates" href="/docs/templates#authts" />
  <Card title="Client" href="/docs/auth/client" />
  <Card title="Triggers" href="/docs/auth/triggers" />
</Cards>
