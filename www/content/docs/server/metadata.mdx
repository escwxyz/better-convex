---
title: Metadata
description: Add typed metadata to procedures for middleware configuration
---

## Overview

Procedure metadata allows you to attach typed configuration to individual [procedures](/docs/server/procedures). Middleware can then read this metadata to customize behavior per-procedure.

## Client Metadata (Codegen)

The CLI generates `convex/shared/meta.ts` containing metadata for all procedures. The client uses this to determine function types and auth requirements:

```ts
// Auto-generated by `better-convex dev`
export const meta = {
  user: {
    list: { type: 'query', auth: 'optional' },
    create: { type: 'mutation', auth: 'required', rateLimit: 'user/create' },
  },
  admin: {
    list: { type: 'query', auth: 'required', role: 'admin' },
  },
} as const;
```

<Callout type="warn">
**No secrets in metadata.** Since meta is exported to the client bundle, never store sensitive values like API keys, internal URLs, or configuration secrets in procedure metadata.
</Callout>

## Define Meta Type

Define your meta type and chain `.meta<Meta>()` during [initialization](/docs/server/setup):

```ts title="convex/lib/crpc.ts"
import { initCRPC } from 'better-convex/server';

type Meta = {
  auth?: 'optional' | 'required';
  role?: 'admin';
  rateLimit?: string;
};

const c = initCRPC
  .dataModel<DataModel>()
  .meta<Meta>()
  .create({ ... });
```

## Set Procedure Metadata

Use `.meta()` to set metadata on procedures:

```ts
export const adminOnly = authQuery
  .meta({ role: 'admin' })
  .query(async ({ ctx }) => {
    return ctx.db.query('user').collect();
  });

export const createSession = authMutation
  .meta({ rateLimit: 'session/create' })
  .input(z.object({ token: z.string() }))
  .mutation(async ({ ctx, input }) => {
    return ctx.db.insert('session', { token: input.token, userId: ctx.userId });
  });
```

## Access in Middleware

Access `meta` in middleware to customize behavior:

```ts
const roleMiddleware = c.middleware(({ ctx, meta, next }) => {
  if (meta.role === 'admin' && !ctx.user?.isAdmin) {
    throw new CRPCError({ code: 'FORBIDDEN' });
  }
  return next({ ctx });
});

const rateLimitMiddleware = c.middleware(async ({ ctx, meta, next }) => {
  await rateLimitGuard({
    key: meta.rateLimit ?? 'default',
    userId: ctx.userId,
  });
  return next({ ctx });
});
```

## Default Meta

Set default metadata values in `create()`:

```ts
const c = initCRPC
  .dataModel<DataModel>()
  .meta<Meta>()
  .create({
    defaultMeta: { auth: 'optional' },
    query,
    mutation,
  });

// All procedures start with { auth: 'optional' }
```

## Chaining (Shallow Merge)

Chaining `.meta()` calls shallow merges values:

```ts
export const publicQuery = c.query;
// Meta: { auth: 'optional' } (from defaultMeta)

export const authQuery = c.query
  .meta({ auth: 'required' });
// Meta: { auth: 'required' }

export const adminQuery = authQuery
  .meta({ role: 'admin' });
// Meta: { auth: 'required', role: 'admin' }

export const rateLimitedAdmin = adminQuery
  .meta({ rateLimit: 'admin/heavy' });
// Meta: { auth: 'required', role: 'admin', rateLimit: 'admin/heavy' }
```

## Common Patterns

### Auth Level

```ts
type Meta = {
  auth?: 'optional' | 'required';
};

export const optionalAuthQuery = c.query
  .meta({ auth: 'optional' })
  .use(async ({ ctx, next }) => {
    const user = await getSessionUser(ctx);
    return next({ ctx: { ...ctx, user } });
  });

export const authQuery = c.query
  .meta({ auth: 'required' })
  .use(async ({ ctx, next }) => {
    const user = await getSessionUser(ctx);
    if (!user) throw new CRPCError({ code: 'UNAUTHORIZED' });
    return next({ ctx: { ...ctx, user } });
  });
```

### Role-Based Access

```ts
type Meta = {
  role?: 'admin';
};

const roleMiddleware = c.middleware(({ ctx, meta, next }) => {
  if (meta.role === 'admin' && !ctx.user?.isAdmin) {
    throw new CRPCError({
      code: 'FORBIDDEN',
      message: 'Admin access required',
    });
  }
  return next({ ctx });
});

export const adminQuery = authQuery
  .meta({ role: 'admin' })
  .use(roleMiddleware);

// Usage
export const list = adminQuery
  .query(async ({ ctx }) => {
    return ctx.db.query('user').collect();
  });
```

### Rate Limiting

```ts
type Meta = {
  rateLimit?: string;
};

const rateLimitMiddleware = c.middleware(async ({ ctx, meta, next }) => {
  if (meta.rateLimit) {
    await rateLimitGuard({
      key: meta.rateLimit,
      userId: ctx.userId,
    });
  }
  return next({ ctx });
});

export const createSession = authMutation
  .meta({ rateLimit: 'session/create' })
  .use(rateLimitMiddleware)
  .mutation(async ({ ctx, input }) => { ... });
```

### Dev Mode

```ts
type Meta = {
  dev?: boolean;
};

const devMiddleware = c.middleware(({ meta, next, ctx }) => {
  if (meta.dev && process.env.NODE_ENV === 'production') {
    throw new CRPCError({
      code: 'FORBIDDEN',
      message: 'This function is only available in development',
    });
  }
  return next({ ctx });
});

export const debugQuery = publicQuery
  .meta({ dev: true })
  .query(async ({ ctx }) => { ... });
```

## Migrate from Convex

### What stays the same

- Custom behavior per procedure

### What's new

**Before (vanilla Convex):**

No built-in metadata system

**After (cRPC):**
```ts
type Meta = { role?: 'admin' };

const c = initCRPC
  .dataModel<DataModel>()
  .meta<Meta>()
  .create({ ... });

export const adminQuery = authQuery
  .meta({ role: 'admin' })
  .use(roleMiddleware);
```

Key differences:
- Type-safe metadata with `Meta` type
- Middleware accesses `meta` parameter
- Chain `.meta()` calls with shallow merge
- `defaultMeta` for default values

## Next steps

<Cards>
  <Card title="Middlewares" href="/docs/server/middlewares" />
  <Card title="Error Handling" href="/docs/server/error-handling" />
</Cards>
